<!DOCTYPE html>
<html lang="en" translate="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover">

    <title>TON Vesting Wallet</title>

    <script src="lib/tonweb-0.0.62.js"></script>
    <!--    <script src="lib/tonconnect-ui-1.0.0-beta.5.min.js"></script>-->
    <script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
    <script src="js/check-smart-contract.js?4"></script>
    <link rel="stylesheet" href="css/main.css?3">
</head>
<body>

<div class="testnet-badge" style="display: none">
    ATTENTION! This is the test network — don’t send real Toncoin!
</div>

<!--Header-->

<div id="header">
    <!-- Badge -->
    <a href="https://ton.org">
        <div id="header_logo"></div>
    </a>
    <div id="header_slash">/</div>
    <div id="header_title">Vesting</div>

    <!-- Header search -->

    <div id="header_input-container">
        <input id="header_input" type="text" placeholder="Enter address">

        <svg class="header_input-icon" width="18" height="18" viewBox="0 0 24 24" fill="none"
             xmlns="http://www.w3.org/2000/svg">
            <path d="M13.0666 17.8667C16.8958 17.8667 20 14.7625 20 10.9333C20 7.10416 16.8958 4 13.0666 4C9.23746 4 6.1333 7.10416 6.1333 10.9333C6.1333 14.7625 9.23746 17.8667 13.0666 17.8667Z"
                  stroke="#98B2BF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
            <path d="M8 16L4 20" stroke="#98B2BF" stroke-width="2" stroke-linecap="round"
                  stroke-linejoin="round"></path>
        </svg>

    </div>

    <div id="header_grow"></div>

    <!-- TON Connect Button -->
    <div id="tonConnectButton"></div>
</div>

<!-- Main Screen -->

<div id="mainScreen" class="screen">
    <div class="main_header">
        Vesting Manager
    </div>

    <div class="main_info">
        Manage wallets with Toncoin locked for some time.
    </div>

    <div class="main_input-container">
        <input class="main_input" placeholder="Enter address">

        <svg class="main_input-icon" width="24" height="24" viewBox="0 0 24 24" fill="none"
             xmlns="http://www.w3.org/2000/svg">
            <path d="M13.0666 17.8667C16.8958 17.8667 20 14.7625 20 10.9333C20 7.10416 16.8958 4 13.0666 4C9.23746 4 6.1333 7.10416 6.1333 10.9333C6.1333 14.7625 9.23746 17.8667 13.0666 17.8667Z"
                  stroke="#98B2BF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
            <path d="M8 16L4 20" stroke="#98B2BF" stroke-width="2" stroke-linecap="round"
                  stroke-linejoin="round"></path>
        </svg>
    </div>
</div>

<!-- Loading Screen -->

<div id="loadingScreen" class="screen">
    <div class="loading"></div>
</div>

<!-- Address Screen-->

<div id="addressScreen" class="screen">
    <div class="address_header">Address</div>
    <div id="address_userAddress" class="address"></div>

    <div id="address_info"></div>

    <div id="address_loading" class="loading"></div>

    <button id="wallet_createButton" class="btn">Create new vesting for this user</button>

    <div id="vesting_container"></div>
</div>

<!-- Create Screen -->

<div id="createScreen" class="screen">
    <div class="create_header">Create new vesting wallet for user</div>
    <div id="create_userAddress" class="address"></div>

    <div style="text-align: center; margin-bottom: 30px; line-height: 150%; color: orangered">
        <b>Do not create vesting smart contracts for addresses managed by SafePal, bots, exchanges etc.</b><br>
        Create vesting only for regular wallets or Ledger from which the recipient knows the seed phrase.
    </div>

    <div id="create_panel">
        <div class="create_label">Vesting start time (local timezone):</div>
        <div class="create_input">
            <input id="create_startTimeInput" type="datetime-local">
        </div>
        <div class="create_label">Total vesting amount (TON):</div>
        <div class="create_input">
            <input id="create_totalAmountInput" type="number">
        </div>
        <div class="create_label">Total vesting duration (days):</div>
        <div class="create_input">
            <input id="create_totalDurationInput" type="number">
        </div>
        <div class="create_label">Cliff duration (days):</div>
        <div class="create_input">
            <input id="create_cliffDurationInput" type="number">
        </div>
        <div class="create_label">Unlock period (days):</div>
        <div class="create_input">
            <input id="create_unlockPeriodInput" type="number">
        </div>

        <label class="checkbox-container"> In masterchain (for direct validation)
            <input type="checkbox" id="create_inMasterchainCheckbox">
            <span class="checkmark"></span>
        </label>

        <div class="create_label">Whitelist:
            <button id="create_addWhitelistButton" class="create_whitelist-btn">+</button>
<!--            <button id="create_addTonstakersWhitelistButton" class="create_whitelist-btn">Add Tonstakers</button>-->
<!--            <button id="create_addElectorWhitelistButton" class="create_whitelist-btn">Add Elector</button>-->
        </div>
        <div id="create_whitelist-container" class="create_whitelist-container"></div>

        <div id="create_error"></div>
        <div id="create_info"></div>
        <button id="create_createButton" class="btn">Create</button>
    </div>
    <div id="create_backBtn">Cancel</div>
</div>

<!-- Modal -->

<div id="modal" style="display: none">

    <!-- Add Whitelist Popup-->

    <div id="addWhitelistPopup">
        <div id="whitelist_label">
            Enter Address:
        </div>
        <input id="whitelist_addressInput" type="text">
        <div id="whitelist_info"></div>
        <button id="whitelist_addButton" class="btn">Add</button>
        <button id="whitelist_useTonstakersPoolButton" class="btn">Use Tonstakers Pool</button>
        <button id="whitelist_useTonstakersJettonButton" class="btn" disabled>Use Tonstakers Jetton</button>
        <button id="whitelist_useElectorButton" class="btn">Use Elector</button>
    </div>

    <!-- Send Popup -->

    <div id="sendPopup" class="sendPopup">
        <input id="sendPopup_toAddressInput" placeholder="Enter destination address" class="sendPopup_input">
        <input id="sendPopup_amountInput" placeholder="Enter amount" class="sendPopup_input" type="number">
        <select id="sendPopup_payloadTypeInput" class="sendPopup_input">
            <option value="text">Text</option>
            <option value="boc">BOC</option>
            <option value="base64">Base64</option>
            <option value="hex">HEX</option>
        </select>
        <input id="sendPopup_payloadInput" placeholder="Enter comment (optional)" class="sendPopup_input">
        <button id="sendPopup_sendButton" class="btn sendPopup_button">Send</button>
    </div>

    <!-- Stake Popup -->

    <div id="stakePopup" class="sendPopup">
        <div id="stakePopup_label" class="stakePopup_label">
            Stake with Tonstakers:
        </div>
        <input id="stakePopup_amountInput" placeholder="Enter amount" class="sendPopup_input" type="number">
        <div id="stakePopup_availableToStake" class="stakePopup_note"></div>
        <button id="stakePopup_sendButton" class="btn sendPopup_button">Stake</button>
    </div>

    <!-- Unstake Popup -->

    <div id="unstakePopup" class="sendPopup">
        <div id="unstakePopup_label" class="stakePopup_label">
            Unstake with Tonstakers:
        </div>
        <input id="unstakePopup_amountInput" placeholder="Enter amount" class="sendPopup_input" type="number">
        <div id="unstakePopup_stakingJettonWalletBalance" class="stakePopup_note"></div>
        <button id="unstakePopup_sendButton" class="btn sendPopup_button">Unstake</button>
    </div>
</div>

<script>
    // UI COMMON

    /**
     * @param selector  {string}
     * @return {HTMLElement | null}
     */
    const $ = (selector) => document.querySelector(selector);

    /**
     * @param selector  {string}
     * @return {NodeListOf<HTMLElement>}
     */
    const $$ = (selector) => document.querySelectorAll(selector);

    /**
     * @param element {HTMLElement}
     * @param isVisible {boolean}
     */
    const toggle = (element, isVisible) => {
        element.style.display = isVisible ? 'flex' : 'none';
    }

    /**
     * @param input {HTMLElement}
     * @param handler   {() => void}
     */
    function onInput(input, handler) {
        input.addEventListener('change', handler);
        input.addEventListener('input', handler);
        input.addEventListener('cut', handler);
        input.addEventListener('paste', handler);
    }

    /**
     * @param s {string}
     */
    const checkHTML = (s) => {
        if (s.indexOf('<') > -1 || s.indexOf('>') > -1) throw new Error('html injection');
    }

    /**
     * @param s {string}
     * @return {string}
     */
    const bold = (s) => {
        checkHTML(s);
        return '<b>' + s + '</b>';
    }

    /**
     * @param address   {string}
     * @return {string}
     */
    const scanLink = (address) => {
        checkHTML(address);
        if (!TonWeb.utils.Address.isValid(address)) throw new Error('invalid address');
        return `https://${IS_TESTNET ? 'testnet.' : ''}tonscan.org/address/${address}`;
    }

    /**
     * @param name  {'addWhitelistPopup' | 'sendPopup' | 'stakePopup' | 'unstakePopup'}
     */
    const showPopup = (name) => {
        const popups = ['addWhitelistPopup', 'sendPopup', 'stakePopup', 'unstakePopup'];
        toggle($('#modal'), true);

        for (const popup of popups) {
            toggle($('#' + popup), popup === name);
        }
    }

    const hidePopup = () => {
        toggle($('#modal'), false);
    }

    $('#modal').addEventListener('click', () => hidePopup());

    /**
     * @type {'mainScreen' | 'addressScreen' | 'createScreen' | 'loadingScreen'}
     */
    let currentScreen = 'mainScreen';

    /**
     * @param name {'mainScreen' | 'addressScreen' | 'createScreen' | 'loadingScreen'}
     */
    const showScreen = (name) => {
        const screens = ['mainScreen', 'addressScreen', 'createScreen', 'loadingScreen']
        currentScreen = name;
        for (const screen of screens) {
            toggle($('#' + screen), screen === name);
        }
        $('#header_input-container').style.visibility = name !== 'mainScreen' ? 'visible' : 'hidden';
        if (name === 'mainScreen') {
            setTimeout(() => {
                $('.main_input').focus();
            }, 10);
        }
        hidePopup();
    }

    showScreen('mainScreen');

    // PAGE

    /** @type {string} */
    const browserLang = navigator.language || navigator.userLanguage;
    /** @type {'ru' | 'en'} */
    const lang = (browserLang === 'ru-RU') || (browserLang === 'ru') || (browserLang === 'be-BY') || (browserLang === 'be') || (browserLang === 'kk-KZ') || (browserLang === 'kk') ? 'ru' : 'en';

    /** @type {boolean} */
    const IS_TESTNET = window.location.href.indexOf('testnet=true') > -1;
    const IS_CUSTOM_OWNERS = window.location.href.indexOf('custom_owners=true') > -1;

    if (IS_TESTNET) {
        $('.testnet-badge').style.display = 'block';
        document.body.classList.add('testnet-padding');
    }

    // TONCONNECT

    /** @type {TonConnectUI} */
    const tonConnectUI = new TON_CONNECT_UI.TonConnectUI({
        manifestUrl: 'https://vesting.ton.org/tonconnect-manifest.json',
        buttonRootId: 'tonConnectButton'
    });

    tonConnectUI.uiOptions = {
        uiPreferences: {
            theme: TON_CONNECT_UI.THEME.LIGHT
        }
    };

    const tonConnectUnsubscribe = tonConnectUI.onStatusChange(info => {
        if (info === null) {
            onWalletDisconnected();
        } else if (info.account) {
            onWalletConnected(info.account);
        }
    });

    // TONWEB COMMON

    const BN = TonWeb.utils.BN;
    const fromNano = TonWeb.utils.fromNano;
    const toNano = TonWeb.utils.toNano;
    const TONCENTER_URL = 'http://94.100.16.239/http/v2/jsonRPC';
    const TONCENTER_INDEX_URL = 'http://94.100.16.239/indexer/v3/';
    const tonweb = new TonWeb(new TonWeb.HttpProvider(TONCENTER_URL));

    // STAKING COMMON

    /** @type {string} */
    const STAKING_CONTRACT_ADDRESS = IS_TESTNET ? 'kQCu_j-5niSEIN_R3qJMWvcjKSdpBJOFz1sJE9JXt549GAW8' : 'EQCkWxfyhAkim3g2DjKQQg8T5P4g-Q1-K_jErGcDJZ4i-vqR';
    /** @type {string} */
    const STAKE_TOKEN_NAME = 'tsTON';
    /** @type {string} */
    const UNSTAKE_PAYLOAD = 0x595f07bc
    /** @type {string} */
    const STAKE_PAYLOAD = 0x47d54391
    /** @type {string} */
    const REF_PAYLOAD = 0x000000106796caef
    /** @type {string} */
    const STAKING_FEE_RES = "1.5"
    /** @type {string} */
    const STAKE_FEE = "1"
    /** @type {string} */
    const UNSTAKE_FEE = "1.05"

    // ELECTOR COMMON

    /** @type {string} */
    const ELECTOR_CONTRACT_ADDRESS = 'Ef8zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM0vF';

    // VESTING COMMON

    /**
     * @return {string}
     */
    const nowToInputValue = () => {
        const now = new Date();
        now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
        return now.toISOString().slice(0, 16);
    }

    /**
     * in UTC timezone
     * @param timestamp {number} unixtime
     * @return {string}
     */
    const formatDateTime = (timestamp) => {
        const date = new Date(timestamp * 1000);
        return date.toUTCString();
    }

    /**
     * @param seconds   {number}
     * @return {string}
     */
    const formatPeriod = (seconds) => {
        const d = Math.floor(seconds / (3600 * 24));
        const h = Math.floor(seconds % (3600 * 24) / 3600);
        const m = Math.floor(seconds % 3600 / 60);
        const s = Math.floor(seconds % 60);

        const arr = [
            d === 0 ? '' : d + ' days',
            h === 0 ? '' : h + ' hours',
            m === 0 ? '' : m + ' min',
            s === 0 ? '' : s + ' sec'
        ]

        return arr.filter(s => s !== '').join(' ');
    }

    /**
     * @param nano  {BN}
     * @param token {string}
     * @return {string}
     */
    const formatAmount = (nano, token = 'TON') => {
        return fromNano(nano) + ' ' + token;
    }

    /**
     *
     * @param info  {{vestingStartTime: number, vestingTotalDuration: number, unlockPeriod: number, cliffDuration: number, vestingTotalAmount: BN }}
     * @return {string}
     */
    const formatVestingInfo = (info) => {
        /** @type {number} */
        const cliffEndTime = info.vestingStartTime + info.cliffDuration;
        /** @type {number} */
        const vestingEndTime = info.vestingStartTime + info.vestingTotalDuration;

        /** @type {BN} */
        const cliffPeriodsCount = new BN(info.cliffDuration).div(new BN(info.unlockPeriod));
        /** @type {BN} */
        const periodsCount = new BN(info.vestingTotalDuration).div(new BN(info.unlockPeriod));

        /** @type {BN} */
        const cliffAmount = info.vestingTotalAmount.mul(cliffPeriodsCount).div(periodsCount);

        /** @type {BN} */
        const unlockAmount = info.unlockPeriod === info.vestingTotalDuration ? new BN(0) :
            info.vestingTotalAmount.div(periodsCount);

        /** @type {string} */
        const startsString = `Vesting starts at ${bold(formatDateTime(info.vestingStartTime))}.`;
        /** @type {string} */
        const cliffString = info.cliffDuration ? ` Cliff period ends in ${bold(formatPeriod(info.cliffDuration))} at ${bold(formatDateTime(cliffEndTime))}, at this moment ${bold(formatAmount(cliffAmount))} will be unlocked.` : ` No cliff period.`;
        /** @type {string} */
        const unlockString = info.unlockPeriod < info.vestingTotalDuration ? ` After that ${bold(formatAmount(unlockAmount))} will be unlock every ${bold(formatPeriod(info.unlockPeriod))}.` : ``;

        return `${startsString} ${cliffString} ${unlockString}<br>
        Total amount ${bold(formatAmount(info.vestingTotalAmount))} will be unlocked in ${bold(formatPeriod(info.vestingTotalDuration))} at ${bold(formatDateTime(vestingEndTime))}.
`
    }

    /**
     * @param address   {string}
     * @return {string}
     */
    const formatAddress = (address) => {
        checkHTML(address);
        if (!TonWeb.utils.Address.isValid(address)) throw new Error('invalid address');
        return `${address.substring(0, address.length / 2)}<wbr>${address.substring(address.length / 2)}`
    }

    /**
     * @param container {HTMLElement}
     * @param list  {string[]}
     * @param senderAddressString   {string}
     * @param isCreateScreen    {boolean}
     */
    const renderWhitelist = (container, list, senderAddressString, isCreateScreen) => {
        /** @type {string} */
        const senderBadge = ` <div class="badge badge-blue">Sender</div>`;
        /** @type {string} */
        const tonstakersBadge = ` <div class="badge badge-blue">Tonstakers</div>`;
        /** @type {string} */
        const electorBadge = isCreateScreen ? `` :  ` <div class="badge badge-blue">Elector</div>`; // do not fit in create mobile screen

        /**
         * @param i {number}
         * @return {string}
         */
        const removeButton = (i) => isCreateScreen ? `<button class="create_whitelist-btn" onclick="removeWhitelist(${i})">-</button>` : ``;

        /** @type {string} */
        let s = '';
        for (let i = 0; i < list.length; i++) {
            /** @type {string} */
            const address = list[i];
            const isSender = address === senderAddressString;
            const isTonstakersPool = address === STAKING_CONTRACT_ADDRESS;
            const isTonstakersJetton = address === stakingJettonWalletAddress || address === createState?.stakingJettonWalletAddress;
            const isElector = address === ELECTOR_CONTRACT_ADDRESS;
            const badge = isSender ? senderBadge : (isTonstakersPool || isTonstakersJetton ? tonstakersBadge : (isElector ? electorBadge : ''));
            const title = isSender ? 'Sender address' : (isTonstakersPool ? 'Tonstakers Pool' : (isTonstakersJetton ? 'Tonstakers Jetton' : (isElector ? 'Elector' : 'Address')));
            s += `<div class="create_whitelist-row">
                <div class="create_whitelist-num">${i + 1}.</div>
                <a class="create_whitelist-address address" href="${scanLink(address)}" title="${title}" target="_blank">
                    ${formatAddress(address)}
                </a>
                ${badge + (isSender ? '' : removeButton(i))}
            </div>`;
        }
        container.innerHTML = s;
    }

    // STATE

    /** @type {string | null} */
    let currentAddress = null; // user-friendly

    /** @type {string | null} */
    let myAddress = null; // user-friendly
    /** @type {string | null} */
    let userAddress = null;
    /** @type {string | null} */
    let userPublicKey = null; // hex

    /** @type {VestingWalletV1 | null} */
    let vestingWallet = null;

    /** @type {string | null} */
    let stakingJettonWalletAddress = null;

    // NAVIGATE

    /** @type {number} */
    let reloadTimeoutId = 0;

    const clear = () => {
        currentAddress = null;
        vestingWallet = null;
        clearTimeout(reloadTimeoutId);
    }

    const goHome = () => {
        clear();
        window.history.pushState('', 'TON Vesting ', '#');
        showScreen('mainScreen');
    }

    $('#header_title').addEventListener('click', () => {
        goHome();
    });

    /**
     * @param address   {string}
     */
    const getStakingJettonWalletAddress = async (address) => {
        const STAKING_JETTON_MINTER_ADDRESS_INDEX = 12;
        try {
            const stakingContractResponse = await tonweb.provider.call2(STAKING_CONTRACT_ADDRESS, 'get_pool_full_data');
            const stakingJettonMinterAddress = stakingContractResponse[STAKING_JETTON_MINTER_ADDRESS_INDEX]?.beginParse().loadAddress();
            if (!stakingJettonMinterAddress) throw new Error("stakingJetton minter address is not found.");

            const queryAddress = new TonWeb.utils.Address(address);
            const addressCell = new TonWeb.boc.Cell();
            addressCell.bits.writeAddress(queryAddress);
            const serializedQueryAddress = TonWeb.utils.bytesToBase64(await addressCell.toBoc(false));

            const walletResponse = await tonweb.provider.call2(stakingJettonMinterAddress.toString(), 'get_wallet_address', [['tvm.Slice', serializedQueryAddress]]);
            if (!walletResponse) throw new Error("stakingJetton wallet is not found.");

            const stakingJettonWalletAddress = walletResponse.beginParse().loadAddress()

            return stakingJettonWalletAddress.toString(true, true, true, IS_TESTNET)

        } catch (error) {
            throw error;
        }
    };

    /**
     * @param address   {string}
     */
    const setAddress = (address) => {
        currentAddress = address;
        vestingWallet = null;
        stakingJettonWalletAddress = null;

        $('.address_header').innerText = 'Address';
        $('#address_info').innerText = '';
        showScreen('addressScreen');
        $('#address_userAddress').innerHTML = `<a href="${scanLink(address)}" target="_blank">${formatAddress(address)}</a>`;
        toggle($('#wallet_createButton'), false);
        toggle($('#vesting_container'), false);
        toggle($('#address_loading'), true);
        $('#header_input').value = '';
        $('.main_input').value = '';

        clearTimeout(reloadTimeoutId);

        const loadAddress = async () => {
            let walletInfo;

            try {
                walletInfo = await tonweb.provider.getWalletInfo(address);
            } catch (e) {
                console.error(e);
            }

            if (address !== currentAddress) return;

            console.log(walletInfo);

            try {
                stakingJettonWalletAddress = await getStakingJettonWalletAddress(address);
            } catch (e) {
                console.error("Error fetching stakingJetton wallet:", e);
            }

            if (!walletInfo) {

                toggle($('#address_loading'), false);
                $('#address_info').innerText = `Can't get this address. Try again..`;
                reloadTimeoutId = setTimeout(loadAddress, 5 * 1000); // reload after 5 seconds

            } else if (walletInfo.account_state === 'uninitialized') {

                toggle($('#address_loading'), false);
                $('#address_info').innerText = 'Address uninitialized yet';
                reloadTimeoutId = setTimeout(loadAddress, 5 * 1000); // reload after 5 seconds

            } else if (walletInfo.wallet === true) {

                toggle($('#address_loading'), false);
                $('.address_header').innerText = 'Wallet';
                toggle($('#wallet_createButton'), true);
                $('#address_info').innerHTML = 'This is a normal wallet.<br>' +
                    'You can create a vesting for this user.';

            } else {
                const addressInfo = await tonweb.provider.getAddressInfo(address);
                if (address !== currentAddress) return;

                /** @type {string} */
                const code098hash = '28030eb57f905fda5cbdc1b08955faf53065759063b958f36c6f861b2bcfc7be';
                /** @type {string} */
                const code099hash = '320ae22be268161d685a7900de30dfec797b797ec9801069ac5b7850750254a2';

                /**
                 * @param codeHexOrBytes    {string | Uint8Array}
                 * @return {Promise<string>} hash hex
                 */
                const getCodeHash =  async (codeHexOrBytes) => {
                    /** @type {Cell} */
                    const codeCell = TonWeb.boc.Cell.oneFromBoc(codeHexOrBytes);
                    return TonWeb.utils.bytesToHex(await codeCell.hash());
                }

                const VestingWalletClass = TonWeb.LockupWallets.VestingWalletV1;
                /** @type {string} */
                const vestingWalletCodeHash = await getCodeHash(VestingWalletClass.codeHex);

                /** @type {string} */
                const addressInfoCodeHash = await getCodeHash(TonWeb.utils.base64ToBytes(addressInfo.code));

                if (addressInfoCodeHash === code098hash) {
                    console.log('Its not production vesting-v0.98 smart contract. Please use vesting-v1.00');
                }
                if (addressInfoCodeHash === code099hash) {
                    console.log('Its not production vesting-v0.99 smart contract. Please use vesting-v1.00');
                }

                if (vestingWalletCodeHash === addressInfoCodeHash) {

                    const newVestingWallet = new VestingWalletClass(tonweb.provider, {
                        address: new TonWeb.utils.Address(address)
                    });

                    /** @type {BN} */
                    const lockedAmount = await newVestingWallet.getLockedAmount(Math.floor(Date.now() / 1000));
                    const vestingData = await newVestingWallet.getVestingData();
                    console.log(vestingData);

                    vestingData.index = 0;
                    vestingData.address = address;
                    vestingData.balance = new BN(addressInfo.balance);
                    vestingData.lockedAmount = lockedAmount;
                    vestingData.ownerAddress = vestingData.ownerAddress.toString(true, true, false, IS_TESTNET);
                    vestingData.vestingSenderAddress = vestingData.vestingSenderAddress.toString(true, true, false, IS_TESTNET);
                    const whitelist = await newVestingWallet.getWhitelist();
                    vestingData.whitelist = [];

                    /**
                     * @param address   {string}
                     * @return {Promise<boolean>}
                     */
                    const checkIsWallet = async (address) => {
                        const value = localStorage.getItem('format_' + address);
                        if (value === 'true' || value === 'false') {
                            return value === 'true';
                        }
                        const walletInfoRaw = await fetch(TONCENTER_INDEX_URL + 'wallet?address=' + address, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                        });
                        const walletInfo = await walletInfoRaw.json();
                        const isWallet = (walletInfo.wallet_type && walletInfo.wallet_type.startsWith('wallet')) || (walletInfo.status === 'uninit');
                        localStorage.setItem('format_' + address, isWallet.toString());
                        return isWallet;
                    }

                    if (stakingJettonWalletAddress) {
                        const unstakeStakingJettonBalanceEl = $('#unstakePopup_stakingJettonWalletBalance');
                        const vestingStakingJettonBalanceEl = $('#vesting_stakingJettonBalance');
                        const jettonAddressButton = $('#whitelist_useTonstakersJettonButton')
                    
                        if (jettonAddressButton) {
                            jettonAddressButton.disabled = false;
                        }

                        try {
                            const stakingJettonWallet = new TonWeb.token.jetton.JettonWallet(tonweb.provider, { address: stakingJettonWalletAddress });
                            const stakingJettonWalletData = await stakingJettonWallet.getData();

                            vestingData.jettonBalance = stakingJettonWalletData.balance;

                            if (unstakeStakingJettonBalanceEl) {
                                unstakeStakingJettonBalanceEl.innerHTML =
                                    `Available: ${bold(formatAmount(vestingData.jettonBalance, STAKE_TOKEN_NAME))}<br/>
                                    Additionally, ${UNSTAKE_FEE} TON will be sent from the vesting wallet to settle fees`;
                            }
                        } catch (e) {
                            // Can't get stakingJetton wallet data
                        }
                    }

                    for (const address of whitelist) {
                        const isWallet = await checkIsWallet(address.toString(false));
                        vestingData.whitelist.push(address.toString(true, true, !isWallet, IS_TESTNET));
                    }
                    if (address !== currentAddress) return;
                    hidePopup(); // close probably opened popups related to old vestingWallet
                    vestingWallet = newVestingWallet;

                    $('#address_info').innerText = '';
                    toggle($('#address_loading'), false);
                    $('.address_header').innerText = 'Vesting';
                    toggle($('#vesting_container'), true);

                    $('#vesting_container').innerHTML = '';
                    $('#vesting_container').appendChild(renderVestingWallet(vestingData));

                } else {

                    toggle($('#address_loading'), false);
                    $('#address_info').innerText = 'Unknown smart contract on this address';
                    toggle($('#wallet_createButton'), IS_CUSTOM_OWNERS);

                }
            }
        }

        loadAddress();
    }

    /**
     * @param e {KeyboardEvent}
     */
    const onAddressInput = e => {
        if (e.key === 'Enter') {
            let addressString = e.target.value.trim();
            if (!TonWeb.utils.Address.isValid(addressString)) {
                alert('Invalid address');
            } else {
                window.history.pushState(addressString, 'TON Vesting - ' + addressString, '#' + addressString);
                setAddress(addressString);
            }
        }
    }

    $('.main_input').addEventListener('keydown', onAddressInput);
    $('#header_input').addEventListener('keydown', onAddressInput);

    const processUrl = () => {
        clear();

        const addressFromUrl = window.location.hash.substring(1);
        if (addressFromUrl) {
            if (TonWeb.utils.Address.isValid(addressFromUrl)) {
                setAddress(addressFromUrl);
            } else {
                showScreen('mainScreen')
            }
        } else {
            showScreen('mainScreen')
        }
    }

    processUrl();

    window.onpopstate = () => processUrl();

    // TONCONNECT CONNECT/DISCONNECT

    /**
     * @param account   {{address: string, publicKey:  string}}
     */
    const onWalletConnected = account => {
        myAddress = new TonWeb.utils.Address(account.address).toString(true, true, false, IS_TESTNET);

        console.log('my address ', myAddress);

        if (currentScreen !== 'mainScreen') {
            setAddress(currentAddress); // refresh
        }
        hidePopup();
    };

    const onWalletDisconnected = () => {
        if (currentScreen !== 'mainScreen') {
            setAddress(currentAddress); // refresh
        }
        hidePopup();
        myAddress = null;
    }

    // WALLET SCREEN

    $('#wallet_createButton').addEventListener('click', async (event) => {
        if (!tonConnectUI.connected || !myAddress) {
            alert('Connect wallet first');
            return;
        }
        const newCreateState = {
            myAddress,
            currentAddress
        };
        showScreen('loadingScreen');

        /** @type {BN} */
        let publicKey;

        try {
            publicKey = await tonweb.provider.call2(currentAddress, 'get_public_key');
        } catch (e) {
            console.error(e);
            if (IS_CUSTOM_OWNERS) {
                publicKey = new BN(0);
            }
        }

        if (!publicKey) {
            alert('Cant get publicKey of target wallet');
            showScreen('addressScreen');
            return;
        }

        if (currentScreen !== 'loadingScreen' || myAddress !== newCreateState.myAddress || currentAddress !== newCreateState.currentAddress) {
            return;
        }

        userAddress = currentAddress;
        userPublicKey = publicKey.toString(16);
        if (userPublicKey.length % 2 !== 0) userPublicKey = '0' + userPublicKey;

        console.log('user address ', userAddress);
        console.log('user key ', userPublicKey);

        renderCreateScreen();
        showScreen('createScreen');
    });

    // VESTING SCREEN

    /**
     * @param vestingWalletInfo {{index: number, address: string, balance: BN, lockedAmount: BN, ownerAddress: string, vestingSenderAddress: string, whitelist: string[],  vestingStartTime: number, vestingTotalDuration: number, unlockPeriod: number, cliffDuration: number, vestingTotalAmount: BN}}
     * @return {HTMLDivElement}
     */
    const renderVestingWallet = (vestingWalletInfo) => {
        /** @type {BN} */
        let liquidAmount = vestingWalletInfo.balance.sub(vestingWalletInfo.lockedAmount);
        if (liquidAmount.lt(new BN(0))) liquidAmount = new BN(0);

        /** @type {BN} */
        let stakingAvailableAmount = vestingWalletInfo.balance.sub(toNano(STAKING_FEE_RES));
        if (stakingAvailableAmount.lt(new BN(0))) stakingAvailableAmount = new BN(0);

        /** @type {string} */
        const unlockString = vestingWalletInfo.unlockPeriod === vestingWalletInfo.vestingTotalDuration ? '-' :
            `Every ${formatPeriod(vestingWalletInfo.unlockPeriod)} ${vestingWalletInfo.cliffDuration > 0 ? 'after cliff period' : ''}`;

        /** @type {number} */
        const index = vestingWalletInfo.index;

        /** @type {string[]} */
        const whitelist = [vestingWalletInfo.vestingSenderAddress].concat(vestingWalletInfo.whitelist);

        /** @type {boolean} */
        const isSender = myAddress === vestingWalletInfo.vestingSenderAddress;

        /** @type {boolean} */
        const isOwner = myAddress === vestingWalletInfo.ownerAddress;

        /** @type {boolean} */
        const isStakingContractWhitelisted = vestingWalletInfo.whitelist.includes(STAKING_CONTRACT_ADDRESS);

        const div = document.createElement('div');
        div.innerHTML =
            `
<div class="vesting_panel">
${isSender ? `<div class="badge panel-badge badge-blue">You are sender</div>` : ``}
${isOwner ? `<div class="badge panel-badge badge-blue">You are owner</div>` : ``}

    <div class="vesting_key">
        Vesting for user:
    </div>
    <div class="vesting_value">
        <a href="${scanLink(vestingWalletInfo.ownerAddress)}" target="_blank" class="address vesting_address">${formatAddress(vestingWalletInfo.ownerAddress)}</a>
    </div>

    <div class="vesting_key">
        Current Balance: <div class="vesting_hint">i<div class="vesting_hint_body">The current balance of the vesting address.</div></div>
    </div>
    <div class="vesting_value">
        ${formatAmount(vestingWalletInfo.balance)}
        ${vestingWalletInfo.jettonBalance ? `<div id="vesting_stakingJettonBalance">${formatAmount(vestingWalletInfo.jettonBalance, STAKE_TOKEN_NAME)}</div>` : ''}
    </div>

    <div class="vesting_key">
        Liquid: <div class="vesting_hint">i<div class="vesting_hint_body">The owner may transfer that amount from the vesting address.</div></div>
    </div>
    <div class="vesting_value">
         ${formatAmount(liquidAmount)}
    </div>

    <div class="vesting_key">
        Unvested: <div class="vesting_hint">i<div class="vesting_hint_body">This amount is subject to restriction on transfer from the vesting address. The owner may transfer that amount only to whitelisted addresses.</div></div>
    </div>
    <div class="vesting_value strong">
         ${formatAmount(BN.min(vestingWalletInfo.lockedAmount, vestingWalletInfo.balance))}
    </div>

    <div class="vesting_key">
        Total Vesting Amount: <div class="vesting_hint">i<div class="vesting_hint_body">Total amount to be vested during the vesting period according to the initial contract parameters. The actual balance may be more or less than this amount.</div></div>
    </div>
        <div class="vesting_value">
         ${formatAmount(vestingWalletInfo.vestingTotalAmount)}
    </div>

    <div class="vesting_key">
        Vesting Start Date: <div class="vesting_hint">i<div class="vesting_hint_body">The date-time when the vesting starts. Before that time coins will not be vested.</div></div>
    </div>
   <div class="vesting_value">
         ${formatDateTime(vestingWalletInfo.vestingStartTime)}
    </div>

    <div class="vesting_key">
        Vesting Duration: <div class="vesting_hint">i<div class="vesting_hint_body">The total duration of the vesting. On that date all coins will be vested.</div></div>
    </div>
   <div class="vesting_value">
        ${formatPeriod(vestingWalletInfo.vestingTotalDuration)}
    </div>

    <div class="vesting_key">
        Cliff Duration: <div class="vesting_hint">i<div class="vesting_hint_body">During this period vesting will be accumulated but coins won't be released. At expiration of the cliff all accumulated coins will be vested all at once.</div></div>
    </div>
   <div class="vesting_value">
        ${vestingWalletInfo.cliffDuration === 0 ? 'No cliff' : formatPeriod(vestingWalletInfo.cliffDuration)}
    </div>

    <div class="vesting_key">
        Unlock Period: <div class="vesting_hint">i<div class="vesting_hint_body">Granularity of the vesting calculation.</div></div>
    </div>
   <div class="vesting_value strong">
        ${unlockString}
    </div>

    <div class="vesting_key">
        Vested Amount: <div class="vesting_hint">i<div class="vesting_hint_body">The amount that should be vested by now from the initially set Total Vesting Amount.</div></div>
    </div>
   <div class="vesting_value">
       ${formatAmount(vestingWalletInfo.vestingTotalAmount.sub(vestingWalletInfo.lockedAmount))}
    </div>

    <div class="vesting_key">
        Unvested Amount: <div class="vesting_hint">i<div class="vesting_hint_body">The amount that should stay restricted by now from the initially set Total Vesting Amount.</div></div>
    </div>
   <div class="vesting_value strong">
        ${formatAmount(vestingWalletInfo.lockedAmount)}
    </div>

    <div class="vesting_info">
        ${formatVestingInfo(vestingWalletInfo)}
    </div>

    <div class="create_label">Whitelist:</div>
    <div class="create_whitelist-container"></div>

    ${isOwner ? `<button id="vesting_sendBtn${index}" class="btn">Send from Vesting</button>` : ``}
    ${isSender ? `<button id="vesting_addWhitelistBtn${index}" class="btn">Add whitelist</button>` : ``}
    ${isOwner && isStakingContractWhitelisted ?
        `<div class="vesting_3rd">
            <div class="vesting_3rd-title">Use with 3rd party</div>
            <button id="vesting_stakeBtn${index}" class="btn">Stake with Tonstakers</button>
            <button id="vesting_unstakeBtn${index}" class="btn vesting_unstakeBtn" ${stakingJettonWalletAddress ? '' : 'disabled'}>Unstake with Tonstakers</button>
        </div>` : ``}
</div>`

        renderWhitelist(div.querySelector('.create_whitelist-container'), whitelist, vestingWalletInfo.vestingSenderAddress, false);

        // div.querySelector('#vesting_all-parameters-btn' + index).addEventListener('click', () => {
        //     const needShow = $('#vesting_all-parameters-container' + index).style.display !== 'flex';
        //     $('#vesting_all-parameters-btn' + index).innerText = needShow ? 'Hide all parameters' : 'Show all parameters';
        //     toggle($('#vesting_all-parameters-container' + index), needShow);
        // });

        div.querySelector('#vesting_addWhitelistBtn' + index)?.addEventListener('click', () => {
            showAddWhitelistPopup(false);
        });

        div.querySelector('#vesting_sendBtn' + index)?.addEventListener('click', () => {
            $('#sendPopup_toAddressInput').value = '';
            $('#sendPopup_amountInput').value = '';
            $('#sendPopup_payloadInput').value = '';
            showPopup('sendPopup');
        });

        $('#stakePopup_availableToStake').innerHTML = `Available: ${bold(formatAmount(stakingAvailableAmount))}<br/>${STAKING_FEE_RES} TON reserved for fees`;

        div.querySelector('#vesting_stakeBtn' + index)?.addEventListener('click', () => {
            $('#stakePopup_amountInput').value = '';
            showPopup('stakePopup');
        });

        div.querySelector('#vesting_unstakeBtn' + index)?.addEventListener('click', () => {
            $('#unstakePopup_amountInput').value = '';
            showPopup('unstakePopup');
        });

        return div;
    }

    // STAKE AND UNSTAKE

    const prepareTonstakersPayload = async (payloadType, inputAmount = null, toAddress = null, waitTillRoundEnd = false, fillOrKill = false) => {
        const payload = new TonWeb.boc.Cell();
        payload.bits.writeUint(payloadType, 32);

        switch (payloadType) {
            case STAKE_PAYLOAD:
                payload.bits.writeUint(1, 64);
                payload.bits.writeUint(REF_PAYLOAD, 64);
                break;
            case UNSTAKE_PAYLOAD:
                payload.bits.writeUint(0, 64);
                payload.bits.writeCoins(inputAmount.toNumber());

                const queryAddress = new TonWeb.utils.Address(currentAddress);
                payload.bits.writeAddress(queryAddress);

                const refCell = new TonWeb.boc.Cell();
                refCell.bits.writeUint(Number(waitTillRoundEnd), 1);
                refCell.bits.writeUint(Number(fillOrKill), 1);

                payload.bits.writeBit(1);
                payload.refs.push(refCell);

                break;
        }

        return payload.toBoc(false);
    }

    $('#stakePopup_sendButton').addEventListener('click', async () => {
        /** @type {BN} */
        let amount;
        try {
            const amountString = $('#stakePopup_amountInput').value;
            if (!amountString) throw new Error();
            amount = toNano(amountString);
            if (!amount.gt(new BN(0))) throw new Error();
            amount = amount.add(toNano(STAKE_FEE));
        } catch (e) {
            alert('Not valid amount');
            return;
        }

        const toAddress = STAKING_CONTRACT_ADDRESS
        const payload = TonWeb.boc.Cell.oneFromBoc(await prepareTonstakersPayload(STAKE_PAYLOAD));

        sendFromVesting(toAddress, amount, payload);
    });

    $('#unstakePopup_sendButton').addEventListener('click', async () => {
        /** @type {BN} */
        let amount;
        try {
            const amountString = $('#unstakePopup_amountInput').value;
            if (!amountString) throw new Error();
            amount = toNano(amountString);
            if (!amount.gt(new BN(0))) throw new Error();
        } catch (e) {
            alert('Not valid amount');
            return;
        }

        const toAddress = stakingJettonWalletAddress;
        const payload = TonWeb.boc.Cell.oneFromBoc(await prepareTonstakersPayload(UNSTAKE_PAYLOAD, amount));

        sendFromVesting(toAddress, toNano(UNSTAKE_FEE), payload);
    });

    // SEND

    $('#sendPopup_sendButton').addEventListener('click', () => {
        /** @type {string} */
        const toAddress = $('#sendPopup_toAddressInput').value;
        if (!toAddress || !TonWeb.utils.Address.isValid(toAddress)) {
            alert('Not valid address');
            return;
        }

        /** @type {BN} */
        let amount;
        try {
            const amountString = $('#sendPopup_amountInput').value;
            if (!amountString) throw new Error();
            amount = toNano(amountString);
            if (!amount.gt(new BN(0))) throw new Error();
        } catch (e) {
            alert('Not valid amount');
            return;
        }

        /** @type {string} */
        const payloadValue = $('#sendPopup_payloadInput').value;

        /** @type {Cell | Uint8Array | string | undefined} */
        let payload = undefined;

        if (payloadValue.length > 0) {
            switch ($('#sendPopup_payloadTypeInput').value) {
                case 'text':
                    payload = payloadValue;
                    break;
                case 'base64':
                    payload = TonWeb.utils.base64ToBytes(payloadValue);
                    break;
                case 'hex':
                    payload = TonWeb.utils.hexToBytes(payloadValue);
                    break;
                case 'boc':
                    payload = TonWeb.boc.Cell.oneFromBoc(TonWeb.utils.base64ToBytes(payloadValue));
                    break;
                default:
                    throw new Error('Invalid payload type');
            }
        }

        sendFromVesting(toAddress, amount, payload);
    });

    /**
     * @param toAddress {string}
     * @param amountBN  {BN}
     * @param messagePayload? {string | Uint8Array | Cell}
     * @return {Promise<void>}
     */
    const sendFromVesting = async (toAddress, amountBN, messagePayload) => {
        /** @type {Address} */
        const vestingWalletAddress = await vestingWallet.getAddress();
        /** @type {Cell} */
        const payload = vestingWallet.createInternalTransfer({
            address: toAddress, // NOTE: if the vesting has not yet expired, we can only send bounceable messages to the whitelist. Since smart contracts (staking) are added to the whitelist, but not regular wallets, the destination address will be entered in bounceable format. No additional actions are required.
            amount: amountBN,
            payload: messagePayload
        });
        /** @type {string} */
        const payloadBase64 = TonWeb.utils.bytesToBase64(await payload.toBoc(false));
        console.log('payload', payloadBase64);

        const amountString = vestingWalletAddress.toString(false).startsWith('-1') ? '0.5' : '0.05';

        const transaction = {
            validUntil: Math.floor(Date.now() / 1000) + 60, // 1 minute
            messages: [
                {
                    address: vestingWalletAddress.toString(true, true, true, IS_TESTNET),
                    amount: toNano(amountString).toString(),
                    payload: payloadBase64,  // raw one-cell BoC encoded in Base64
                }
            ]
        }

        try {
            const result = await tonConnectUI.sendTransaction(transaction);
            hidePopup();
        } catch (e) {
            console.error(e);
        }
    }

    // CREATE SCREEN

    /**
     * @type {{whitelistAddresses: string[], info: null | {vestingStartTime: number, vestingTotalDuration: number, unlockPeriod: number, cliffDuration: number, vestingTotalAmount: BN}}}
     */
    const createState = {
        info: null,
        whitelistAddresses: [],
    }

    $('#create_backBtn').addEventListener('click', event => {
        showScreen('addressScreen');
    });

    $('#create_createButton').addEventListener('click', async (event) => {
        const vestingWallet = getVestingInstance();

        /** @type {Address} */
        const vestingWalletAddress = await vestingWallet.getAddress();
        /** @type {string} */
        const addressString = vestingWalletAddress.toString(true, true, true, IS_TESTNET);
        console.log('Vesting = ', addressString);
        /** @type {Cell} */
        const stateInitCell = (await vestingWallet.createStateInit()).stateInit;
        /** @type {string} */
        const stateInitBase64 = TonWeb.utils.bytesToBase64(await stateInitCell.toBoc(false));
        console.log({stateInitBase64})
        /** @type {Address[]} */
        const addresses = createState.whitelistAddresses.map(addressString => new TonWeb.utils.Address(addressString));
        /** @type {Cell} */
        const payload = addresses.length ? vestingWallet.createAddWhitelistBody({addresses}) : undefined;
        /** @type {string} */
        const payloadBase64 = payload ? TonWeb.utils.bytesToBase64(await payload.toBoc(false)) : undefined;
        console.log({payloadBase64});

        const transaction = {
            validUntil: Math.floor(Date.now() / 1000) + 60,
            messages: [
                {
                    address: addressString,
                    amount: toNano('0.5').toString(),
                    payload: payloadBase64,  // raw one-cell BoC encoded in Base64
                    stateInit: stateInitBase64 // raw once-cell BoC encoded in Base64.
                }
            ]
        }

        let isError = false;
        try {
            const result = await tonConnectUI.sendTransaction(transaction);
        } catch (e) {
            isError = true;
            console.error(e);
        }

        if (!isError) {
            window.history.pushState(addressString, 'TON Vesting - ' + addressString, '#' + addressString);
            setAddress(addressString);
        }
    });

    /**
     * @return {VestingWallet}
     */
    const getVestingInstance = () => {
        /** @type {0 | -1} */
        const wc = $('#create_inMasterchainCheckbox').checked ? -1 : 0;
        console.log({ wc });

        // todo: prevent deploy if elector or config in whitelist, but wc == 0

        const VestingWalletClass = TonWeb.LockupWallets.VestingWalletV1;
        const vestingWallet = new VestingWalletClass(tonweb.provider, {
            wc: wc,
            publicKey: TonWeb.utils.hexToBytes(userPublicKey),
            vestingStartTime: createState.info.vestingStartTime,
            vestingTotalDuration: createState.info.vestingTotalDuration,
            unlockPeriod: createState.info.unlockPeriod,
            cliffDuration: createState.info.cliffDuration,
            vestingTotalAmount: createState.info.vestingTotalAmount,
            vestingSenderAddress: new TonWeb.utils.Address(myAddress),
            ownerAddress: new TonWeb.utils.Address(userAddress)
        });

        return vestingWallet;
    }

    /**
     * @return {{vestingStartTime: number, vestingTotalDuration: number, unlockPeriod: number, cliffDuration: number, vestingTotalAmount: BN}}
     */
    const validateCreate = () => {
        if (!$('#create_startTimeInput').value) {
            throw 'Enter start time';
        }

        if (!$('#create_totalAmountInput').value) {
            throw 'Enter amount';
        }

        if (!$('#create_totalDurationInput').value) {
            throw 'Enter total duration';
        }

        if (!$('#create_cliffDurationInput').value) {
            throw 'Enter cliff duration, if no cliff enter 0';
        }

        if (!$('#create_unlockPeriodInput').value) {
            throw 'Enter unlock period';
        }

        /** @type {string} */
        const startTimeString = $('#create_startTimeInput').value;
        /** @type {number} */
        const startTime = Math.floor(new Date(startTimeString).getTime() / 1000);

        /** @type {BN} */
        let amountNano;
        try {
            const amountString = $('#create_totalAmountInput').value;
            amountNano = toNano(amountString);
            if (!amountNano) throw new Error();
        } catch (e) {
            throw 'Invalid amount';
        }

        /** @type {number} */
        const totalDurationDays = Number($('#create_totalDurationInput').value);
        /** @type {number} */
        const totalDurationSeconds = Math.round(totalDurationDays * 24 * 60 * 60);
        /** @type {number} */
        const vestingEndTime = startTime + totalDurationSeconds;

        /** @type {number} */
        const cliffDurationDays = Number($('#create_cliffDurationInput').value);
        /** @type {number} */
        const cliffDurationSeconds = Math.round(cliffDurationDays * 24 * 60 * 60);
        /** @type {number} */
        const cliffEndTime = startTime + cliffDurationSeconds;

        /** @type {number} */
        const unlockPeriodDays = Number($('#create_unlockPeriodInput').value);
        /** @type {number} */
        const unlockPeriodSeconds = Math.round(unlockPeriodDays * 24 * 60 * 60);

        /**
         * @param x {any}
         * @param error {string}
         */
        const require = (x, error) => {
            if (isNaN(x) || x === undefined || x === null) {
                throw error;
            }
        }

        require(startTime, 'Enter Start Time')
        require(totalDurationSeconds, 'Enter Total Duration')
        require(cliffDurationSeconds, 'Enter Cliff Duration')
        require(unlockPeriodSeconds, 'Enter Unlock Period')
        require(cliffEndTime, '')
        require(vestingEndTime, '')

        if (!amountNano.gte(new TonWeb.utils.BN(1e9))) {
            throw 'Minimum 1 TON';
        }

        if (startTime < 0) {
            throw 'Start time must be greater than zero';
        }

        if (totalDurationSeconds <= 0) {
            throw 'Total Duration must be greater than zero';
        }

        if (totalDurationSeconds > 2 ** 32 -1) {
            throw 'Total Duration must be less than 135 years';
        }

        if (cliffDurationSeconds < 0) {
            throw 'Cliff Duration must be greater than or equal to zero`';
        }

        if (cliffEndTime >= vestingEndTime) {
            throw 'Total Duration must be greater than Cliff Duration';
        }

        if (unlockPeriodSeconds <= 0) {
            throw 'Unlock Period must be greater than zero';
        }

        if (startTime + unlockPeriodSeconds > vestingEndTime) {
            throw 'Unlock Period must be less than or equal to Total Duration';
        }

        /**
         * @param x {number}
         * @param y {number}
         * @return {boolean}
         */
        const isDivisible = (x, y) => {
            if (x === 0) return true;
            return Math.floor(x / y) * y === x;
        }

        if (!isDivisible(totalDurationSeconds, unlockPeriodSeconds)) {
            throw 'Total Duration must be evenly divisible by Unlock Period';
        }

        if (!isDivisible(cliffDurationSeconds, unlockPeriodSeconds)) {
            throw 'Cliff Duration must be evenly divisible by Unlock Period';
        }

        return {
            vestingStartTime: startTime, // unixtime in seconds
            vestingTotalDuration: totalDurationSeconds, // seconds
            unlockPeriod: unlockPeriodSeconds, // seconds
            cliffDuration: cliffDurationSeconds, // seconds
            vestingTotalAmount: amountNano
        }
    }

    const updateCreate = async () => {
        $('#create_createButton').disabled = true;

        createState.info = null;
        try {
            createState.info = validateCreate();
        } catch (e) {
            $('#create_error').innerText = e;
        }
        toggle($('#create_error'), !Boolean(createState.info));
        $('#create_createButton').disabled = !Boolean(createState.info);

        $('#create_info').innerHTML = createState.info ? formatVestingInfo(createState.info) : '';

        if (createState.info) {
            const vestingWallet = getVestingInstance();
            const vestingWalletAddress = await vestingWallet.getAddress();
            try {
                const stakingJettonWalletAddress = await getStakingJettonWalletAddress(vestingWalletAddress.toString(true, true, true, IS_TESTNET));
                const stakingJettonWalletAddressSting = stakingJettonWalletAddress.toString(true, true, true, IS_TESTNET);

                if (createState.whitelistAddresses.includes(createState.stakingJettonWalletAddress)) {
                    createState.whitelistAddresses = createState.whitelistAddresses.map(address => address === createState.stakingJettonWalletAddress ? stakingJettonWalletAddressSting : address);
                    createState.stakingJettonWalletAddress = stakingJettonWalletAddressSting;
                    renderCreateWhitelist();
                } else {
                    createState.stakingJettonWalletAddress = stakingJettonWalletAddressSting;
                }
            } catch (error) {
                console.log(error);
            }
        }
    }

    onInput($('#create_startTimeInput'), updateCreate);
    onInput($('#create_totalAmountInput'), updateCreate);
    onInput($('#create_totalDurationInput'), updateCreate);
    onInput($('#create_cliffDurationInput'), updateCreate);
    onInput($('#create_unlockPeriodInput'), updateCreate);
    onInput($('#create_inMasterchainCheckbox'), updateCreate);

    const renderCreateScreen = () => {
        createState.whitelistAddresses = [];
        createState.info = null;

        $('#create_userAddress').innerHTML = `<a href="${scanLink(userAddress)}" target="_blank">${formatAddress(userAddress)}</a>`;

        $('#create_inMasterchainCheckbox').checked = false;
        $('#create_startTimeInput').value = nowToInputValue();

        $('#create_totalAmountInput').value = '';
        $('#create_totalDurationInput').value = '';
        $('#create_cliffDurationInput').value = '';
        $('#create_unlockPeriodInput').value = '';

        renderCreateWhitelist();
        updateCreate();
    }

    // ADD WHITELIST POPUP

    /** @type {string | null} */
    let addressForCheck = null;

    /**
     * @return {Promise<void>}
     */
    const onWhitelistAddressInput = async () => {
        /** @type {string} */
        const value = $('#whitelist_addressInput').value;

        if (value && TonWeb.utils.Address.isValid(value)) {
            if (addressForCheck !== value) {
                addressForCheck = value;
                $('#whitelist_info').innerText = 'Loading..';
                /** @type {{status: 'SUCCESS' | 'INVALID' | 'NO_RESPONSE', text: string}} */
                const info = await checkSmartContract(tonweb, new TonWeb.utils.Address(value));
                if (value === addressForCheck) {
                    // todo: disable Add button if INVALID or NO_RESPONSE
                    // todo: disable Add button if single-nominator.owner !== vestingWalletAddress
                    $('#whitelist_info').innerText = info.text;
                }
            }
        } else {
            $('#whitelist_info').innerText = 'Invalid address';
            addressForCheck = null;
        }
    }

    onInput($('#whitelist_addressInput'), onWhitelistAddressInput);
    onWhitelistAddressInput();

    /**
     * @param isCreate  {boolean}
     */
    const showAddWhitelistPopup = (isCreate) => {
        $('#whitelist_useTonstakersPoolButton').style.display = isCreate ? 'none' : 'block';
        $('#whitelist_useTonstakersJettonButton').style.display = isCreate ? 'none' : 'block';
        addressForCheck = null;
        $('#whitelist_addressInput').value = '';
        $('#whitelist_info').innerText = '';
        showPopup('addWhitelistPopup');
    }

    // CREATE WHITELIST

    const renderCreateWhitelist = () => {
        renderWhitelist($('#create_whitelist-container'), [myAddress].concat(createState.whitelistAddresses), myAddress, true);
    }

    /**
     * @param index {number}
     */
    const removeWhitelist = (index) => {
        createState.whitelistAddresses.splice(index - 1, 1);
        renderCreateWhitelist();
    }

    $('#create_addWhitelistButton').addEventListener('click', () => {
        showAddWhitelistPopup(true);
    });

    /**
     * @param newAddress {string}
     */
    const whitelistPredefinedAddress = (newAddress) => {
        for (let address of createState.whitelistAddresses) {
            if (isEqualAddresses(address, newAddress)) {
                return;
            }
        }

        createState.whitelistAddresses.push(newAddress);
        renderCreateWhitelist();
    }

    // $('#create_addTonstakersWhitelistButton').addEventListener('click', () => {
    //     whitelistPredefinedAddress(STAKING_CONTRACT_ADDRESS)
    //     if (createState.stakingJettonWalletAddress) {
    //         whitelistPredefinedAddress(createState.stakingJettonWalletAddress)
    //     } else if (stakingJettonWalletAddress) {
    //         createState.stakingJettonWalletAddress = stakingJettonWalletAddress
    //         whitelistPredefinedAddress(createState.stakingJettonWalletAddress)
    //     }
    // });

    // $('#create_addElectorWhitelistButton').addEventListener('click', () => {
    //     whitelistPredefinedAddress(ELECTOR_CONTRACT_ADDRESS)
    // });

    $('#addWhitelistPopup').addEventListener('click', e => e.stopImmediatePropagation());
    $('#sendPopup').addEventListener('click', e => e.stopImmediatePropagation());
    $('#stakePopup').addEventListener('click', e => e.stopImmediatePropagation());
    $('#unstakePopup').addEventListener('click', e => e.stopImmediatePropagation());

    /**
     * @param a {string}
     * @param b {string}
     * @return {boolean}
     */
    const isEqualAddresses = (a, b) => {
        return new TonWeb.utils.Address(a).toString(false) === new TonWeb.utils.Address(b).toString(false);
    }

    $('#whitelist_useTonstakersPoolButton').addEventListener('click', async () => {
        $('#whitelist_addressInput').value = STAKING_CONTRACT_ADDRESS;
        onWhitelistAddressInput();
    });

    $('#whitelist_useTonstakersJettonButton').addEventListener('click', async () => {
        $('#whitelist_addressInput').value = createState?.stakingJettonWalletAddress || stakingJettonWalletAddress;
        onWhitelistAddressInput();
    });

    $('#whitelist_useElectorButton').addEventListener('click', async () => {
        $('#whitelist_addressInput').value = ELECTOR_CONTRACT_ADDRESS;
        onWhitelistAddressInput();
    });

    $('#whitelist_addButton').addEventListener('click', async () => {
        hidePopup();

        /** @type {string} */
        const newAddress = $('#whitelist_addressInput').value;

        if (!newAddress || !TonWeb.utils.Address.isValid(newAddress)) {
            return;
        }

        if (isEqualAddresses(myAddress, newAddress)) {
            return;
        }

        for (let address of createState.whitelistAddresses) {
            if (isEqualAddresses(address, newAddress)) {
                return;
            }
        }

        if (currentScreen === 'createScreen') {

            createState.whitelistAddresses.push(newAddress);
            renderCreateWhitelist();

        } else if (currentScreen === 'addressScreen') {

            /** @type {Address} */
            const vestingWalletAddress = await vestingWallet.getAddress();
            /** @type {Cell} */
            const payload = vestingWallet.createAddWhitelistBody({addresses: [new TonWeb.utils.Address(newAddress)]});
            /** @type {string} */
            const payloadBase64 = TonWeb.utils.bytesToBase64(await payload.toBoc(false));
            console.log('payload', payloadBase64);

            const transaction = {
                validUntil: Math.floor(Date.now() / 1000) + 60,
                messages: [
                    {
                        address: vestingWalletAddress.toString(true, true, true, IS_TESTNET),
                        amount: toNano('0.5').toString(),
                        payload: payloadBase64,  // raw one-cell BoC encoded in Base64
                    }
                ]
            }

            let isError = false;

            try {
                const result = await tonConnectUI.sendTransaction(transaction);
            } catch (e) {
                isError = true;
                console.error(e);
            }

            if (!isError) {
            }

        }
    });
</script>

</body>
</html>